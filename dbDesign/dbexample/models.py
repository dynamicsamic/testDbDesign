import datetime as dt
from decimal import Decimal
from typing import Any, Mapping

from django.conf import settings
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractUser
from django.core.exceptions import ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import IntegrityError, models
from django.db.models import F, Sum
from django.db.models.query import QuerySet
from django.http.request import HttpRequest
from django.utils.text import slugify
from django.utils.translation import gettext_lazy as _

from .exceptions import EmptyQuerySet, NotEnoughProductLeft, TooBigToAdd
from .utils import decimalize

MAX_AMOUNT_ADDED = 10000


class AutoGeneratedSlugModel(models.Model):
    """Get model instances with auto generated slug fields."""

    slug = models.SlugField(
        "url safe string",
        max_length=150,
        blank=True,
        help_text=_(
            "required, allowed=[letters, numbers, hyphens, underscore], max_len: 150"
        ),
    )

    class Meta:
        abstract = True

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        return super().save(*args, **kwargs)


class UserRoleManager(models.Manager):

    # def create(self, **kwargs):
    #    """Create an empty cart when creating a customer."""
    #    customer = super().create(**kwargs)
    #    Cart.objects.create(customer=customer)
    #    return customer

    def get_queryset(self) -> QuerySet:
        """Fetch user data when querying for Role object."""
        return super().get_queryset().select_related("user")


class ProxyUserRole(models.Model):
    """Abstract class for implementing user roles.
    Like customer, moderator, admin, etc.
    """

    user = None

    objects = UserRoleManager()

    class Meta:
        abstract = True

    def __str__(self) -> str:
        return self.username

    @property
    def username(self) -> str:
        return self.user.get_username()

    @property
    def email(self) -> str:
        return self.user.email

    @email.setter
    def email(self, new_email: str) -> None:
        self.user.email = new_email
        self.user.save(update_fields=("email",))

    @property
    def first_name(self) -> str:
        return self.user.first_name

    @first_name.setter
    def first_name(self, new_first_name: str) -> None:
        self.user.first_name = new_first_name
        self.user.save(update_fields=("first_name",))

    @property
    def last_name(self) -> str:
        return self.user.last_name

    @last_name.setter
    def last_name(self, new_last_name: str) -> None:
        self.user.last_name = new_last_name
        self.user.save(update_fields=("last_name",))

    @property
    def full_name(self) -> str:
        return self.user.get_full_name()

    @property
    def last_login(self) -> dt.datetime or None:
        return self.user.last_login

    @property
    def date_joined(self) -> dt.datetime:
        return self.user.date_joined

    @property
    def is_active(self) -> bool:
        return self.user.is_active

    @property
    def is_anonymous(self) -> bool:
        return self.user.is_anonymous

    @property
    def is_authenticated(self) -> bool:
        return self.user.is_authenticated

    @property
    def groups(self):
        return self.user.groups


class User(AbstractUser):
    email = models.EmailField(_("email adress"), unique=True)
    is_active = models.BooleanField(
        _("active"),
        default=False,
        help_text=_(
            "Designates whether this user should be treated as active. "
            "Unselect this instead of deleting accounts."
        ),
    )


class Customer(ProxyUserRole):
    class CustomerStatus(models.TextChoices):
        CREATED = "created"
        ACTIVATED = "activated"
        FROZEN = "frozen"
        ARCHIVED = "archived"

    user = models.OneToOneField(
        get_user_model(),
        related_name="customer",
        on_delete=models.CASCADE,
    )
    status = models.CharField(
        _("Customer status"),
        max_length=20,
        choices=CustomerStatus.choices,
        default=CustomerStatus.CREATED,
        help_text=_("required, default: created"),
    )
    phone_number = models.CharField(
        _("Customer phone number"),
        max_length=15,
        help_text=_("optional, max_len: 15"),
        blank=True,
        null=True,
    )


class Moderator(ProxyUserRole):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        related_name="moderator",
        on_delete=models.CASCADE,
    )


'''
class Address(models.Model):
    """Physical address."""

    class Elevator(models.TextChoices):
        """Elevator type."""

        REGULAR = "regular"
        CARGO = "cargo"
        COMBINED = "combined"
        NONE = "none"

    country = models.CharField(
        _("name of the country"),
        max_length=120,
        help_text="required, max_len: 120",
    )
    subregion = ...
    town = ...
    street = ...
    building = ...
    floor = ...
    elevator = models.CharField(
        _("elevator type"),
        max_length=10,
        choices=Elevator.choices,
        blank=True,
        null=True,
        help_text=_("optional"),
    )
    zip_code = ...
'''


class Agent(models.Model):
    name = models.CharField(
        _("name of the agent/partner"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )
    # adress = models.ForeignKey(
    #    Address, related_name="agents", on_delete=models.PROTECT
    # )
    address = models.CharField(max_length=200)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


class Supplier(Agent):
    pass


class Vendor(AutoGeneratedSlugModel):
    name = models.CharField(
        _("manufacturer name"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )
    description = models.TextField(
        _("product vendor brief info"),
        max_length=2000,
        blank=True,
        null=True,
        help_text=_("optional, max_len: 2000"),
    )


class Brand(AutoGeneratedSlugModel):
    name = models.CharField(
        _("brand name"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )
    description = models.TextField(
        _("brand brief info"),
        max_length=2000,
        blank=True,
        null=True,
        help_text=_("optional, max_len: 2000"),
    )
    logo = models.CharField(_("replace this to imagefield"), max_length=30)
    vendor = models.ForeignKey(
        Vendor,
        related_name="brands",
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )

    def __str__(self):
        return self.name


class ProductAttribute(models.Model):
    """Attribute of a product.
    Like `cpu`, `storage`, `RAM` etc.
    """

    name = models.CharField(
        _("product item attribute name"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )

    def __str__(self):
        return self.name


class ProductType(AutoGeneratedSlugModel):
    name = models.CharField(
        _("type of product"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )
    logo = models.CharField(_("replace this to imagefield"), max_length=30)
    attribute_set = models.ManyToManyField(
        ProductAttribute,
        related_name="product_types",
        through="ProductTypeToAttributeLinkTable",
    )

    def __str__(self):
        return self.name


class ProductTypeToAttributeLinkTable(models.Model):
    """Link table for product type and attribute values."""

    product_type = models.ForeignKey(ProductType, on_delete=models.PROTECT)
    attr = models.ForeignKey(
        ProductAttribute,
        on_delete=models.PROTECT,
    )

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["product_type", "attr"],
                name="unique_product_type_attr",
            )
        ]

    def __str__(self) -> str:
        return f"{self.product_type_id}: {self.attr_id}"


class ProductCategory(AutoGeneratedSlugModel):
    """
    Category for products.
    """

    name = models.CharField(
        _("product category name"),
        max_length=100,
        unique=True,
        help_text=_("required, max_len: 100"),
    )
    is_active = models.BooleanField(
        _("product category active status"),
        default=True,
        help_text=_("optional, defalut: True"),
    )

    class Meta:
        verbose_name = _("Product category")
        verbose_name_plural = _("Product categories")

    def __str__(self):
        return self.name


class ProductSet(AutoGeneratedSlugModel):
    """
    A set of products (like particular model of a laptop).
    """

    web_id = models.CharField(
        _("product_set web id"),
        unique=True,
        max_length=50,
        help_text=_("required, numbers"),
    )
    name = models.CharField(
        _("product_set name"),
        max_length=150,
        help_text=_("required, max_len: 150"),
    )
    description = models.TextField(
        _("product_set description"),
        max_length=2000,
        help_text=_("required, max_len: 2000"),
    )
    categories = models.ManyToManyField(
        ProductCategory,
        related_name="productsets",
        # verbose_name=_("productset categories"),
    )
    p_type = models.ForeignKey(
        ProductType, related_name="productsets", on_delete=models.PROTECT
    )
    brand = models.ForeignKey(
        Brand, related_name="productsets", on_delete=models.PROTECT
    )
    is_active = models.BooleanField(
        _("product_set status"),
        default=False,
        help_text=_("bool; optional; default: False"),
    )
    created_at = models.DateTimeField(
        _("product_set creation time"),
        auto_now_add=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
    updated_at = models.DateTimeField(
        _("product_set last update time"),
        auto_now=True,
        help_text=_("format: Y-m-d H:M:S"),
    )

    def __str__(self):
        return self.name


class ProductItemManager(models.Manager):
    def create(self, **kwargs):
        """On creation set product item name generated from its product set name and attrs.
        Create stock and set its initial amount to quantity if passed from user.
        """
        # product_name
        # kwargs.update({'product_name'})
        p_set = kwargs.get("product_set")
        attrs = kwargs.get("attrs")
        # print(attrs.values())
        if attrs:
            p_name = p_set.name + " " + " ".join(attrs.values())
        else:
            p_name = p_set.name
        kwargs.update({"product_name": p_name})
        product_item = super().create(**kwargs)
        product_item.set_sku()
        # CREATE STOCK INSTANCE ALONG WITH PRODUCT ITEM
        # MANUALLY IN FORMS OR SERIALIZERS
        # stock_qty = kwargs.get("quantity", 0)
        # Stock.objects.create(
        #    product=product_item, unit="pcs", initial_amount=stock_qty
        # )
        return product_item

        # obj = super().create(**kwargs)
        # p_name = obj.product_set.name
        # full_name = p_name + " " + " ".join([attr.value for attr in obj.attrs])
        # obj.product_name = full_name
        # obj.save()
        # return obj


class ProductItem(models.Model):
    """Particular item of product with specific attributes."""

    product_set = models.ForeignKey(
        ProductSet,
        on_delete=models.CASCADE,
        related_name="items",
        help_text=_("Product set this product belongs to."),
    )
    favorited_by = models.ManyToManyField(
        Customer,
        related_name="favorites",
        help_text=_("optional, customers liked the product"),
    )
    product_name = models.CharField(
        _("Product name"),
        help_text=_("optional, max_len: 150"),
        max_length=150,
        blank=True,
        # null=True,
    )
    sku = models.CharField(
        _("stock keeping unit"),
        help_text=_("required, max_len: 20"),
        max_length=20,
        blank=True,
        null=True,
    )
    attrs = models.JSONField(
        _("Attributes for product item "),
        help_text=_("required: dict of attr:vaue pairs"),
    )
    # images = models.ForeignKey(
    #    ImageSet, related_name="product_items", on_delete=models.SET_DEFAULT
    # )
    regular_price = models.DecimalField(
        _("Product item price"),
        help_text=_("required, max_price: 9_999_999.99"),
        max_digits=9,
        decimal_places=2,
    )
    discount = models.PositiveSmallIntegerField(
        _("Discount rate (integer)"),
        help_text=_("required, default: 0"),
        default=0,
        validators=[MaxValueValidator(99)],  # this only works with ModelForm
    )
    # discounted_price = models.DecimalField(
    #    _("Product item final price"),
    #    max_digits=9,
    #    decimal_paces=2,
    #    blank=True,
    #    null=True,
    #    help_text=_("set automatically"),
    # )
    # discount = models.ManyToManyField(Discount)
    is_active = models.BooleanField(
        _("product item status"),
        help_text=_("bool; optional; default: False"),
        default=False,
    )
    _view_count = models.PositiveIntegerField(
        _("number of views"),
        help_text=_("required, starts with 0"),
        default=0,
    )
    made_in = models.CharField(_("change this to country FK"), max_length=150)
    created_at = models.DateTimeField(
        _("product item creation time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now_add=True,
    )
    updated_at = models.DateTimeField(
        _("product item last update time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now=True,
    )

    objects = ProductItemManager()

    class Meta:
        constraints = [
            models.CheckConstraint(
                check=models.Q(discount__lt=100), name="discount_less_than_100"
            )
        ]

    def __str__(self):
        return self.product_name

    @property
    def views(self) -> int:
        return self._view_count

    @property
    @decimalize()
    def discounted_price(self) -> Decimal:
        """Get discounted price."""
        return float(self.regular_price) * ((100 - self.discount) / 100)
        # price = float(self._price) * ((100 - self.discount) / 100)
        # return round(price, 2)

    def increment_view_count(self) -> None:
        """Increment number of customer views by 1."""
        # self._meta.model.objects.filter(id=self.id).update(_view_count=F('_view_count')+1)
        self._view_count += 1
        self.save(update_fields=("_view_count",))

    def _generate_sku(self):
        """Generate sku from product type and product item `ids` and current date."""
        return f"{self.product_set.p_type_id:>03}{self.pk:>02}{dt.datetime.now():%Y%m}"

    def set_sku(self):
        """Set sku and save the model."""
        self.sku = self._generate_sku()
        self.save(update_fields=("sku",))

    # @property
    # def price(self) -> Decimal:
    #    return self._price
    #
    # @price.setter
    # def price(self, value) -> None:
    #    try:
    #        self._price = Decimal(format(value, ".2f"))
    #        self.save(update_fields=("_price",))
    #    except ValueError:
    #        pass

    def to_dict(self) -> dict:
        """Return a dict of product item attributes."""
        return {
            # "product_id": self.id,
            "product_name": self.product_name,
            "sku": self.sku,
            "regular_price": self.regular_price,
            "discount": self.discount,
            "discounted_price": self.discounted_price,
        }


"""
class Media(models.Model):
    product_item = models.ForeignKey(
        ProductItem, related_name="media", on_delete=models.CASCADE
    )
    image = models.ImageField(
        _("product item image"),
        upload_to="/images",
        default="/images/default.jpg",
        help_text="required, default: default.jpg",
    )
    is_cover = models.BooleanField(
        _("is a cover image"),
        default=False,
        help_text="reuqired, default: False",
    )
    created_at = models.DateTimeField(
        _("image creation time"),
        auto_now_add=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
    updated_at = models.DateTimeField(
        _("image last update time"),
        auto_now=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
"""


class Stock(models.Model):
    product = models.OneToOneField(
        ProductItem,
        on_delete=models.PROTECT,
        related_name="stock",
        help_text=_("Product item this stock belongs to."),
    )
    unit = models.CharField(
        _("product unit"),
        help_text=_("required, max_len: 20"),
        max_length=20,
    )
    # initial_amount = models.PositiveIntegerField(
    #    _("initial amount of product"),
    #    default=0,
    #    help_text=_("required, default: 0"),
    # )
    amount = models.PositiveIntegerField(
        _("current amount of product"),
        help_text=_("required, default: 0"),
        default=0,
    )
    items_sold = models.PositiveIntegerField(
        _("amount of product sold"),
        help_text=_("required, default: 0"),
        default=0,
    )
    created_at = models.DateTimeField(
        _("Stock item creation time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now_add=True,
    )
    updated_at = models.DateTimeField(
        _("Stock item last update time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now=True,
    )

    def __str__(self) -> str:
        return f"Product({self.product_id}): {self.amount}"

    def set(self, value: int, commit: bool = True) -> None:
        if value < 0 or value > MAX_AMOUNT_ADDED:
            raise ValidationError(
                f"Value must be between 0 and {MAX_AMOUNT_ADDED}"
            )
        self.amount = value
        if commit:
            self.save(update_fields=("amount",))

    def add(self, value: int, commit: bool = True) -> None:
        if value < 0:
            raise ValidationError("Value must be greater or equal to 0")
        if value > MAX_AMOUNT_ADDED:
            raise TooBigToAdd(value)
        self.amount += value
        if commit:
            self.save(update_fields=("amount",))

    def deduct(self, value: int, commit: bool = True) -> None:
        if value < 0:
            raise ValidationError("Value must be greater or equal to 0")
        if value > self.amount:
            raise NotEnoughProductLeft(self)
        self.amount -= value
        if commit:
            self.save(update_fields=("amount",))

    def available(self, amount: int) -> bool:
        return self.amount >= amount


# class Cart:
#    def __init__(self, request: HttpRequest) -> None:
#        """Get or create a Cart from request."""
#
#        self.session = request.session
#        cart = self.session.get(settings.CART_SESSION_ID)
#        if not cart:
#            cart = self.session[settings.CART_SESSION_ID] = {}
#        self.cart = cart
#
#    def add(
#        self,
#        product: ProductItem,
#        quantity: int = 1,
#        set_quantity: bool = False,
#    ):
#        """Add a product to the cart."""
#
#        product_id = str(product.id)  # maybe leave this a int?
#        if product_id not in self.cart:
#            self.cart[product_id] = {
#                "product": product,
#                "quantity": quantity,
#                "price": product.discounted_price.to_eng_string(),
#            }
#        if set_quantity:
#            self.cart[product_id]["quantity"] = quantity
#        else:
#            self.cart[product_id]["quantity"] += quantity
#        self.save()
#
#    def save(self) -> None:
#        """Mark session as modified."""
#
#        self.session.modified = True
#
#    def remove(self, product: ProductItem) -> None:
#        """Remove a product from the cart."""
#
#        product_id = str(product.id)
#        if product_id in self.cart:
#            del self.cart[product_id]
#            self.save()


class Cart(models.Model):
    # maybe try: Cart.objects.select_related('customer)?
    class CartStatus(models.TextChoices):
        EMPTY = "empty"
        IN_PROGRESS = "in_progress"

    customer = models.OneToOneField(
        Customer,
        related_name="cart",
        on_delete=models.PROTECT,
        verbose_name=_("Cutomer"),
        help_text="required, customer instance",
    )
    status = models.CharField(
        _("Cart status"),
        max_length=20,
        choices=CartStatus.choices,
        default=CartStatus.EMPTY,
        help_text=_("required, default: empty"),
    )
    created_at = models.DateTimeField(
        _("cart creation time"),
        auto_now_add=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
    updated_at = models.DateTimeField(
        _("cart last update time"),
        auto_now=True,
        help_text=_("format: Y-m-d H:M:S"),
    )

    def __str__(self) -> str:
        return f"{self.id} for Customer({self.customer_id})"

    @property
    def empty(self):
        return not self.items.exists()

    @property
    def items_ready_for_order(self):
        return self.items.filter(marked_for_order=True)

    def clear_out(self):
        """Clean the cart."""
        self.items.all().delete()
        self.status = self.CartStatus.EMPTY
        self.save(update_fields=("status", "updated_at"))

    def refresh(self) -> None:
        """Update all cart items from product item info."""
        # think about save() method runs at every item refresh
        for item in self.items.all():
            item.refresh_from_product_item()

    @decimalize()
    def get_initial_sum(self) -> Decimal:
        """Get sum of all items in cart before discount applied."""
        return (
            self.items.filter(marked_for_order=True)
            .aggregate(initial=Sum(F("regular_price") * F("quantity")))
            .get("initial")
            or 0
        )

    @decimalize()
    def get_discounted_sum(self) -> Decimal:
        """Get sum of all items in cart after dicsount added."""
        return (
            self.items.filter(marked_for_order=True)
            .aggregate(discounted=Sum(F("discounted_price") * F("quantity")))
            .get("discounted")
            or 0
        )

    @decimalize()
    def get_total_discount(self) -> Decimal:
        """Get sum of total cart discount."""
        return (
            self.items.filter(marked_for_order=True)
            .aggregate(
                discount=Sum(
                    (F("regular_price") - F("discounted_price"))
                    * F("quantity")
                )
            )
            .get("discount")
            or 0
        )

    def to_dict(self, refresh: bool = False) -> dict:
        """Return a dict of cart attributes."""
        if refresh:
            self.refresh()
        return {
            "customer_id": self.customer_id,
            "initial_sum": self.get_initial_sum(),
            "total_discount": self.get_total_discount(),
            "discounted_sum": self.get_discounted_sum(),
        }


class CartItemManager(models.Manager):
    def create(self, **kwargs: Mapping[str, Any]) -> "CartItem":
        """Check if a product item is already in the cart.
        If it's there - increase or set quantity.
        If it's not - create new cart item.
        """
        cart = kwargs.get("cart")
        product = kwargs.get("product")
        quantity = kwargs.get("quantity", 1)
        override_quantity = kwargs.get("override_quantity", False)
        try:
            cart_item = self.model.objects.get(cart=cart, product=product)
            cart_item.add_quantity(quantity, override_quantity)
        except self.model.DoesNotExist:
            cart_item = super().create(**kwargs)
        except Exception as e:
            print(f"An unexpected error occured: {e}")
            return
        if cart.status == Cart.CartStatus.EMPTY:
            cart.status = Cart.CartStatus.IN_PROGRESS
            cart.save(update_fields=("status",))
        return cart_item

    #   if product := kwargs.get("product"):
    #       kwargs.update(
    #           {
    #               "product_name": product.product_name,
    #               "price": product.discounted_price,
    #           }
    #       )


class CartItem(models.Model):
    cart = models.ForeignKey(
        Cart,
        on_delete=models.CASCADE,
        related_name="items",
        verbose_name=_("Item in cart"),
    )
    product = models.ForeignKey(
        ProductItem,
        on_delete=models.PROTECT,
        related_name="in_cart",
        verbose_name=_("Product item"),
    )
    product_name = models.CharField(
        _("Product name"),
        max_length=150,
        help_text=_("optional, max_len: 150"),
        blank=True,
        null=True,
    )
    sku = models.CharField(
        _("stock keeping unit"),
        max_length=20,
        help_text="optional, max_len: 20",
    )
    quantity = models.PositiveIntegerField(
        _("Product quantity"),
        validators=[MinValueValidator(1)],
        help_text=_("reqiured, positive integer"),
        default=1,
    )
    regular_price = models.DecimalField(
        _("Product item price"),
        max_digits=9,
        decimal_places=2,
        help_text=_("optional, max_price: 9_999_999.99"),
    )
    discount = models.PositiveSmallIntegerField(
        _("Discount rate (integer)"),
        default=0,
        help_text=_("optional, default: 0"),
        validators=[MaxValueValidator(99)],
    )
    discounted_price = models.DecimalField(
        _("Discounted cart item price"),
        max_digits=9,
        decimal_places=2,
        help_text=_("optional, max_price: 9_999_999.99"),
    )
    marked_for_order = models.BooleanField(
        _("Item selected to be ordered"),
        default=True,
        help_text=_("required, default: False"),
    )
    created_at = models.DateTimeField(
        _("cart_item creation time"),
        auto_now_add=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
    updated_at = models.DateTimeField(
        _("cart_item last update time"),
        auto_now=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
    objects = CartItemManager()

    def __str__(self):
        return self.product_name

    def save(self, *args, **kwargs) -> None:
        """Update cart info each time a cart item updated."""
        super().save(*args, **kwargs)
        self.cart.save(update_fields=("updated_at",))

    @classmethod
    def create_from_product_item(
        cls, customer_id: int, product_item_id: int, **kwargs: dict
    ) -> "CartItem":
        """Create CartItem from ProductItem.
        Prevent creating cart items from inactive products
        and products that don't have enough stock items.
        Fetch stock data along with the product item
        to prevent additional db queries.
        """
        try:
            cart = Cart.objects.get(customer_id=customer_id)
            product_item = ProductItem.objects.select_related("stock").get(
                id=product_item_id
            )
        except (Cart.DoesNotExist, ProductItem.DoesNotExist) as e:
            print(e)
            raise
        if not product_item.is_active:
            raise ValidationError(
                _("Inactive products can't be added to cart")
            )
        if not product_item.stock.available(kwargs.get("quantity", 1)):
            raise ValidationError(_("Not enough product in stock"))
            # maybe need to deduct from stock to reserve items for order
            # but then need to keep notice of cleansing the cart periodically
        # product_data = product_item.to_dict()
        # kwargs.update(product_data)
        cart_item = cls.objects.create(
            cart=cart, product=product_item, **kwargs, **product_item.to_dict()
        )
        cart.save(update_fields=("updated_at",))
        return cart_item

    def refresh_from_product_item(self) -> None:
        """Refresh cart item attribute values with product item info."""
        self._meta.model.objects.filter(id=self.id).update(
            **self.product.to_dict()
        )
        # product_info = self.product.to_dict()
        # self.regular_price = product_info.get("regular_price")
        # self.discount = product_info.get("discount")
        # self.discounted_price = product_info.get("discounted_price")
        # self.save(
        #    update_fields=(
        #        "regular_price",
        #        "discount",
        #        "discounted_price",
        #        "updated_at",
        #    )
        # )

    def add_quantity(self, quantity: int, override: bool = False) -> None:
        if override:
            self.quantity = quantity
        else:
            self.quantity += quantity
        self.save(update_fields=("quantity", "updated_at"))

    @decimalize()
    def get_initial_sum(self) -> Decimal:
        """Get sum of product item without discount."""
        return self.regular_price * self.quantity

    @decimalize()
    def get_discounted_sum(self) -> Decimal:
        """Get discounted sum of product item."""
        return self.discounted_price * self.quantity

    @decimalize()
    def get_total_discount(self) -> Decimal:
        """Get amount of discount applied to product item."""
        return (self.regular_price - self.discounted_price) * self.quantity

    def mark_for_order(self) -> None:
        """Mark cart item as ready for order.
        Only marked items are counted in cart sum
        and can be added to order.
        """
        self.marked_for_order = True
        self.save(update_fields=("marked_for_order", "updated_at"))

    def unmark_for_order(self) -> None:
        """Remove mark from cart item.
        This item is not counted in cart sum
        and can not be added to order.
        """
        self.marked_for_order = False
        self.save(update_fields=("marked_for_order", "updated_at"))

    def to_dict(self) -> dict:
        """Return a dict of cart item attributes."""
        return {
            # "cart": self.cart,
            # "product": self.product,
            "product_name": self.product_name,
            "product_id": self.product_id,
            "sku": self.sku,
            "quantity": self.quantity,
            "regular_price": self.regular_price,
            "discount": self.discount,
            "discounted_price": self.discounted_price,
            "initial_sum": self.get_initial_sum(),
            "discounted_sum": self.get_discounted_sum(),
            "total_discount": self.get_total_discount(),
            # "marked_for_order": self.marked_for_order,
        }


class Order(models.Model):
    class OrderStatus(models.TextChoices):
        PENDING = "pending"
        PAID = "paid"
        PROCESSING = "processing"
        DELIVERY_READY = "delivery_ready"
        ON_DELIVERY = "on_delivery"
        DELIVERED = "delivered"
        FINISHED = "finished"
        CANCELED_BY_CUSTOMER = "canceled_by_customer"
        CANCELED_BY_SELLER = "canceled_by_seller"

    customer = models.ForeignKey(
        Customer, related_name="orders", on_delete=models.PROTECT
    )  # change to models.SET_DEFAULT
    _status = models.CharField(
        _("Order status"),
        help_text=_("required, default: pending"),
        max_length=50,
        choices=OrderStatus.choices,
        default=OrderStatus.PENDING,
    )
    # shipment_method = ...
    # payment_method = ...
    # delivery_info = ...  # FK DELIVERY
    initial_sum = models.DecimalField(
        _("order sum without discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        max_digits=12,
        decimal_places=2,
    )
    total_discount = models.DecimalField(
        _("sum of discounts"),
        help_text=_("optional, max_sum: 9 999 999 999.99"),
        max_digits=12,
        decimal_places=2,
        default=0,
    )
    discounted_sum = models.DecimalField(
        _("order sum with discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        max_digits=12,
        decimal_places=2,
    )
    created_at = models.DateTimeField(
        _("order creation time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now_add=True,
    )
    updated_at = models.DateTimeField(
        _("order last update time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now=True,
    )

    def __str__(self) -> str:
        return f"Order {self.id} for customer {self.customer_id}"

    @property
    def status(self) -> str:
        return self._status

    @status.setter
    def status(self, value: str) -> None:
        if stat := getattr(self.OrderStatus, value.upper(), None):
            self._status = stat
        else:
            raise ValueError(f"{value} is not a valid choice for OrderStatus")

    @classmethod
    def create_from_cart(cls, customer_id: int, **kwargs: dict) -> "Order":
        try:
            cart = Cart.objects.get(
                customer_id=customer_id, status=Cart.CartStatus.IN_PROGRESS
            )
        except Cart.DoesNotExist as e:
            print("Create a Cart and add items before creating an order")
            raise e
        # cart = Cart.objects.filter(
        #    customer_id=customer.id, status=Cart.CartStatus.IN_PROGRESS
        # ).first()
        # cart_items = cart.items.all()
        # kwargs.update(cart.to_dict())
        order = cls.objects.create(**kwargs, **cart.to_dict())
        for item in cart.items_ready_for_order:
            OrderItem.create_from_cart_item(order, item)

        # order.final_sum = order.get_total_sum()
        # order.save(update_fields=("final_sum",))
        return order

    def cancel(self):
        """Cancel the order.
        Revert all order items and set specific status."""
        for item in self.items.all():
            item.revert()
        self.status = "canceled_by_seller"
        self.save(update_fields=("_status",))

    # def get_total_sum(self) -> Decimal:
    #    if res := self.items.aggregate(total=Sum("sum")).get("total"):
    #        return res
    #    return Decimal("0.00")

    # def get_total_discount(self) -> float:
    #    # return round(
    #    #    OrderItem.objects.filter(order_id=self.id).aggregate(Sum("sum")), 2
    #    # )
    #    pass


class OrderItem(models.Model):
    order = models.ForeignKey(
        Order,
        related_name="items",
        on_delete=models.CASCADE,
        verbose_name=_("Customer Order"),
    )
    product = models.ForeignKey(
        ProductItem,
        related_name="order_items",
        on_delete=models.PROTECT,
        verbose_name=_("Ordered product"),
    )
    product_name = models.CharField(
        _("Product name"),
        help_text=_("required, max_len: 150"),
        max_length=150,
    )
    sku = models.CharField(
        _("stock keeping unit"),
        help_text=_("required, max_len: 20"),
        max_length=20,
    )
    quantity = models.PositiveIntegerField(
        _("Quantity of ordered product"),
        help_text=_("required: default 1"),
        default=1,
    )
    regular_price = models.DecimalField(
        _("Final price of ordered product"),
        help_text=_("required, max_price: 9 999 999.99"),
        max_digits=9,
        decimal_places=2,
    )
    discount = models.PositiveSmallIntegerField(
        _("Discount rate (integer)"),
        help_text=_("required, default: 0"),
        default=0,
        validators=[MaxValueValidator(99)],
    )
    discounted_price = models.DecimalField(
        _("Discounted oreder item price"),
        help_text=_("required, max_price: 9_999_999.99"),
        max_digits=9,
        decimal_places=2,
    )
    initial_sum = models.DecimalField(
        _("Sum of ordered product without discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        max_digits=12,
        decimal_places=2,
    )
    total_discount = models.DecimalField(
        _("Sum of total discounts applied to ordered product"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        max_digits=12,
        decimal_places=2,
    )
    discounted_sum = models.DecimalField(
        _("Final sum of ordered product with discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        max_digits=12,
        decimal_places=2,
    )
    is_cancelled = models.BooleanField(
        _("Was order item cancelled"),
        help_text=_("required, default: False"),
        default=False,
    )

    def __str__(self) -> str:
        return self.product_name

    @classmethod
    def create_from_cart_item(
        cls, order: Order, cart_item: CartItem, **kwargs
    ) -> "OrderItem":
        """Create an order item from a cart item."""
        data = cart_item.to_dict()
        stock = Stock.objects.filter(product_id=data.get("product_id"))
        quantity = data.get("quantity")
        try:
            success = stock.update(
                amount=F("amount") - quantity,
                items_sold=F("items_sold") + quantity,
            )
        except IntegrityError as e:
            print("invalid quantity")
            raise e
        except Exception as e:
            print(f"unknown error: {e}")
        # if product := data.get("product"):
        #    stock = product.stock
        #    # quantity = data.get("quantity", 1)
        #    # if not stock.available(quantity):
        #    #    raise ValidationError(_("Not enough product in stock"))
        #    # stock.deduct(quantity)
        #    try:
        #        stock.deduct(quantity := data.get("quantity", 1), commit=False)
        #    except NotEnoughProductLeft as e:
        #        print(f"{e(quantity)}")
        #        raise
        #    stock.items_sold += quantity
        #    stock.save(
        #        update_fields=(
        #            "current_amount",
        #            "items_sold",
        #        )
        #    )
        if success:
            # kwargs.update(data)
            cart_item.delete()
            return cls.objects.create(order=order, **kwargs, **data)

    def revert(self) -> None:
        """Restore the quantity of stock units when the order is canceled.
        Set quantity item quantity to 0.
        """
        stock = Stock.objects.filter(product_id=self.product_id)
        try:
            cancelled = stock.update(
                amount=F("amount") + self.quantity,
                items_sold=F("items_sold") - self.quantity,
            )
        except IntegrityError as e:
            print(e)
            print("invalid values; unable to perform update")
            raise e
        except Exception as e:
            print(f"unknown error: {e}")
        # stock = Stock.objects.filter(product_id=self.product_id).first()
        # stock.add(self.quantity, commit=False)
        # stock.items_sold -= self.quantity
        # stock.save(
        #    update_fields=(
        #        "current_amount",
        #        "items_sold",
        #    )
        # )
        # self.quantity = 0
        self.is_cancelled = bool(cancelled)
        self.save(update_fields=("is_cancelled",))


class Comment(models.Model):
    pass


class Foo(models.Model):
    class MAN(models.Manager):
        def create(self, **kwargs):
            kwargs.update({"label": "FFFF"})
            obj = super().create(**kwargs)
            # obj.label = "FFFFFF"
            # obj.save()
            return obj

    objects = MAN()

    label = models.CharField(_("label"), max_length=100)
    attrs = models.JSONField(_("attrs"))
