import datetime as dt
import logging
from decimal import Decimal
from typing import Any, Dict, Literal, Mapping, Tuple

from django.conf import settings
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractUser
from django.core.exceptions import ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import IntegrityError, models
from django.db.models import F, Sum
from django.db.models.query import QuerySet
from django.http.request import HttpRequest
from django.shortcuts import reverse
from django.utils import timezone
from django.utils.text import slugify
from django.utils.translation import gettext_lazy as _

from .exceptions import EmptyQuerySet, NotEnoughProductLeft, TooBigToAdd
from .utils import decimalize

MAX_AMOUNT_ADDED = 10000

decimal_price_settings = {
    "max_digits": 9,
    "decimal_places": 2,
}
decimal_sum_settings = {
    "max_digits": 12,
    "decimal_places": 2,
}

logger = logging.getLogger(__name__)


def updated_at() -> Dict[str, dt.datetime]:
    """Return current time in current timezone.
    Used in update queries.
    """
    return {"updated_at": dt.datetime.now(timezone.get_current_timezone())}


class TimeStampModel(models.Model):
    created_at = models.DateTimeField(
        _("object creation time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now_add=True,
    )
    updated_at = models.DateTimeField(
        _("object last update time"),
        help_text=_("format: Y-m-d H:M:S"),
        auto_now=True,
    )

    class Meta:
        abstract = True


class AutoGeneratedSlugModel(models.Model):
    """Django model with auto generated slug field."""

    slug = models.SlugField(
        "url safe string",
        max_length=150,
        blank=True,
        help_text=_(
            "required, allowed=[letters, numbers, hyphens, underscore], max_len: 150"
        ),
    )

    class Meta:
        abstract = True

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        return super().save(*args, **kwargs)


class UserRoleManager(models.Manager):

    # def create(self, **kwargs):
    #    """Create an empty cart when creating a customer."""
    #    customer = super().create(**kwargs)
    #    Cart.objects.create(customer=customer)
    #    return customer

    def get_queryset(self) -> "QuerySet[ProxyUserRole]":
        """Fetch user data when querying for Role object."""
        return super().get_queryset().select_related("user")


class ProxyUserRole(models.Model):
    """Abstract class for implementing user roles,
    e.g. customer, moderator, admin, etc."""

    user = None

    objects = UserRoleManager()

    class Meta:
        abstract = True

    def __str__(self) -> str:
        return self.username

    @property
    def username(self) -> str:
        return self.user.get_username()

    @property
    def email(self) -> str:
        return self.user.email

    @email.setter
    def email(self, new_email: str) -> None:
        self.user.email = new_email
        self.user.save(update_fields=("email",))

    @property
    def first_name(self) -> str:
        return self.user.first_name

    @first_name.setter
    def first_name(self, new_first_name: str) -> None:
        self.user.first_name = new_first_name
        self.user.save(update_fields=("first_name",))

    @property
    def last_name(self) -> str:
        return self.user.last_name

    @last_name.setter
    def last_name(self, new_last_name: str) -> None:
        self.user.last_name = new_last_name
        self.user.save(update_fields=("last_name",))

    @property
    def full_name(self) -> str:
        return self.user.get_full_name()

    @property
    def last_login(self) -> dt.datetime or None:
        return self.user.last_login

    @property
    def date_joined(self) -> dt.datetime:
        return self.user.date_joined

    @property
    def is_active(self) -> bool:
        return self.user.is_active

    @property
    def is_anonymous(self) -> bool:
        return self.user.is_anonymous

    @property
    def is_authenticated(self) -> bool:
        return self.user.is_authenticated

    @property
    def groups(self):
        return self.user.groups


class User(AbstractUser):
    email = models.EmailField(_("email adress"), unique=True)
    is_active = models.BooleanField(
        _("active"),
        default=False,
        help_text=_(
            "Designates whether this user should be treated as active. "
            "Unselect this instead of deleting accounts."
        ),
    )


class Customer(ProxyUserRole):
    class CustomerStatus(models.TextChoices):
        CREATED = "created"
        ACTIVATED = "activated"
        FROZEN = "frozen"
        ARCHIVED = "archived"

    user = models.OneToOneField(
        get_user_model(),
        on_delete=models.CASCADE,
        related_name="customer",
    )
    status = models.CharField(
        _("Customer status"),
        max_length=20,
        help_text=_("required, default: created"),
        choices=CustomerStatus.choices,
        default=CustomerStatus.CREATED,
    )
    phone_number = models.CharField(
        _("Customer phone number"),
        help_text=_("optional, max_len: 15"),
        max_length=15,
        blank=True,
        null=True,
    )


class Moderator(ProxyUserRole):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="moderator",
    )


'''
class Address(models.Model):
    """Physical address."""

    class Elevator(models.TextChoices):
        """Elevator type."""

        REGULAR = "regular"
        CARGO = "cargo"
        COMBINED = "combined"
        NONE = "none"

    country = models.CharField(
        _("name of the country"),
        max_length=120,
        help_text="required, max_len: 120",
    )
    subregion = ...
    town = ...
    street = ...
    building = ...
    floor = ...
    elevator = models.CharField(
        _("elevator type"),
        max_length=10,
        choices=Elevator.choices,
        blank=True,
        null=True,
        help_text=_("optional"),
    )
    zip_code = ...
'''


class Agent(models.Model):
    name = models.CharField(
        _("name of the agent/partner"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )
    # adress = models.ForeignKey(
    #    Address, related_name="agents", on_delete=models.PROTECT
    # )
    address = models.CharField(max_length=200)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


class Supplier(Agent):
    pass


class Vendor(AutoGeneratedSlugModel):
    name = models.CharField(
        _("manufacturer name"),
        max_length=150,
        unique=True,
        help_text=_("required, max_len: 150"),
    )
    description = models.TextField(
        _("product vendor brief info"),
        max_length=2000,
        blank=True,
        null=True,
        help_text=_("optional, max_len: 2000"),
    )


class Brand(AutoGeneratedSlugModel):
    name = models.CharField(
        _("brand name"),
        help_text=_("required, max_len: 150"),
        max_length=150,
        unique=True,
    )
    description = models.TextField(
        _("brand brief info"),
        help_text=_("optional, max_len: 2000"),
        max_length=2000,
        blank=True,
        null=True,
    )
    logo = models.CharField(_("replace this to imagefield"), max_length=30)
    vendor = models.ForeignKey(
        Vendor,
        on_delete=models.SET_NULL,
        related_name="brands",
        blank=True,
        null=True,
    )

    def __str__(self):
        return self.name


class ProductAttribute(models.Model):
    """Attribute of a product, e.g.`cpu`, `storage`, `RAM` etc."""

    name = models.CharField(
        _("attribute of product"),
        help_text=_("required, max_len: 150"),
        max_length=150,
        unique=True,
    )

    def __str__(self):
        return self.name


class ProductType(AutoGeneratedSlugModel):
    """Type of a product, e.g. `laptops`, `tablets`, `desktops`, etc."""

    name = models.CharField(
        _("type of product"),
        help_text=_("required, max_len: 150"),
        max_length=150,
        unique=True,
    )
    logo = models.CharField(_("replace this to imagefield"), max_length=30)
    attributes = models.ManyToManyField(
        ProductAttribute,
        related_name="product_types",
        through="ProductTypeToAttributeLinkTable",
    )

    def __str__(self):
        return self.name


class ProductTypeToAttributeLinkTable(models.Model):
    """Link table for product type and attribute values."""

    product_type = models.ForeignKey(ProductType, on_delete=models.PROTECT)
    attr = models.ForeignKey(
        ProductAttribute,
        on_delete=models.PROTECT,
    )

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["product_type", "attr"],
                name="unique_product_type_attr",
            )
        ]

    def __str__(self) -> str:
        return f"{self.product_type_id}: {self.attr_id}"


class ProductCategory(AutoGeneratedSlugModel):
    """Category for products."""

    name = models.CharField(
        _("product category name"),
        help_text=_("required, max_len: 100"),
        max_length=100,
        unique=True,
    )
    is_active = models.BooleanField(
        _("product category active status"),
        help_text=_("optional, defalut: True"),
        default=True,
    )

    class Meta:
        verbose_name = _("Product category")
        verbose_name_plural = _("Product categories")

    def __str__(self):
        return self.name


class ProductDiscount(models.Model):
    label = models.CharField(
        _("Discount alphanumeric identificator"),
        help_text=_("required, unique, max_len: 20"),
        max_length=20,
        unique=True,
    )
    rate = models.PositiveSmallIntegerField(
        _("Discount rate"),
        help_text=_("required, integer from 0 to 99"),
        validators=[(MaxValueValidator(99)), MinValueValidator(1)],
    )
    starts_at = models.DateTimeField(
        _("Discount valid from"),
        help_text=_(("required, format: Y-m-d H:M:S")),
    )
    ends_at = models.DateTimeField(
        _("Discount valid by"),
        help_text=_(("required, format: Y-m-d H:M:S")),
    )
    is_active = models.BooleanField(
        _("Discount active status"),
        help_text=_("required, default: False"),
        default=False,
    )

    class Meta:
        constraints = [
            models.CheckConstraint(
                check=models.Q(rate__lt=100),
                name="discount_rate_less_than_100",
            )
        ]

    def __str__(self):
        return (
            f"active: {self.is_active}; {self.starts_at}-"
            f"{self.ends_at}; {self.rate}%"
        )


class Product(AutoGeneratedSlugModel, TimeStampModel):
    """General product without versions (CPU, RAM, color, etc.)."""

    p_type = models.ForeignKey(
        ProductType,
        on_delete=models.PROTECT,
        related_name="products",
    )
    brand = models.ForeignKey(
        Brand,
        on_delete=models.PROTECT,
        related_name="products",
    )
    categories = models.ManyToManyField(
        ProductCategory,
        related_name="products",
        # verbose_name=_("productset categories"),
    )
    web_id = models.CharField(
        _("product web id"),
        help_text=_("required, numbers"),
        unique=True,
        max_length=50,
    )
    name = models.CharField(
        _("product name"),
        help_text=_("required, max_len: 150"),
        max_length=150,
    )
    description = models.TextField(
        _("product description"),
        help_text=_("required, max_len: 2000"),
        max_length=2000,
    )
    is_active = models.BooleanField(
        _("product status"),
        help_text=_("bool; optional; default: False"),
        default=False,
    )
    # created_at = models.DateTimeField(
    #    _("product creation time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now_add=True,
    # )
    # updated_at = models.DateTimeField(
    #    _("product last update time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now=True,
    # )

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse("products", kwargs={"pk": self.pk})

    def set_discount_for_versions(
        self, discount_id: int = -1, discount_label: str = ""
    ) -> int:
        """Assign a discount to all product versions.
        Provide either `discount_id` or `discount_label` or both.
        Returns number of updated product versions.
        (Should be equal to number of all versions)."""
        now = timezone.now()
        if (
            disc := ProductDiscount.objects.filter(
                is_active=True, starts_at__lte=now, ends_at__gt=now
            )
            .filter(models.Q(id=discount_id) | models.Q(label=discount_label))
            .first()
        ):
            return self.versions.update(discount=disc)
        return 0


class ProductVersionManager(models.Manager):
    # def create(self, **kwargs):
    #    """On creation set product version name generated from its product name and attrs.
    #    Create stock and set its initial amount to quantity if passed from user."""
    #    # product_name
    #    # kwargs.update({'product_name'})
    #    product = kwargs.get("product")
    #    attrs = kwargs.get("attrs")
    #    # print(attrs.values())
    #    if attrs:
    #        p_name = product.name + " " + " ".join(attrs.values())
    #    else:
    #        p_name = product.name
    #    kwargs.update({"name": p_name})
    #    p_version = super().create(**kwargs)
    #    p_version.set_sku()
    #    # CREATE STOCK INSTANCE ALONG WITH PRODUCT VERSION
    #    # MANUALLY IN FORMS OR SERIALIZERS
    #    # stock_qty = kwargs.get("quantity", 0)
    #    # Stock.objects.create(
    #    #    product=p_version, unit="pcs", initial_amount=stock_qty
    #    # )
    #    return p_version

    def create(self, **kwargs: Dict[str, Any]) -> "ProductVersion":
        """Concatenate product and version names.
        Create version instance using new name."""

        product = kwargs.get("product")
        version_name = product.name + " " + kwargs.get("name")
        kwargs.update({"name": version_name})
        return super().create(**kwargs)


class ProductVersion(TimeStampModel, models.Model):
    """Specific version of a product
    with its own set of attribute values."""

    product = models.ForeignKey(
        Product,
        on_delete=models.CASCADE,
        related_name="versions",
        help_text=_("required, general product for this version"),
    )
    favorited_by = models.ManyToManyField(
        Customer,
        related_name="favorites",
        help_text=_("optional, customers liked this product version"),
    )
    name = models.CharField(
        _("product version name"),
        help_text=_("version name without product, required, max_len: 150;"),
        max_length=150,
    )
    sku = models.CharField(
        _("Stock keeping unit"),
        help_text=_("required, max_len: 20"),
        max_length=20,
        blank=True,
    )
    attrs = models.JSONField(
        _("Attributes for product version "),
        help_text=_("required: dict of attr:vaue pairs"),
    )
    # images = models.ForeignKey(
    #    ImageSet, related_name="p_versions", on_delete=models.SET_DEFAULT
    # )
    regular_price = models.DecimalField(
        _("Product version price"),
        help_text=_("required, max_price: 9_999_999.99"),
        **decimal_price_settings,
    )
    # discount = models.PositiveSmallIntegerField(
    #    _("Discount rate (integer)"),
    #    help_text=_("required, default: 0"),
    #    default=0,
    #    validators=[MaxValueValidator(99)],  # this only works with ModelForm
    # )
    discount = models.ForeignKey(
        ProductDiscount,
        on_delete=models.SET_NULL,
        related_name="p_versions",
        blank=True,
        null=True,
    )
    # discount = models.ManyToManyField(Discount)
    is_active = models.BooleanField(
        _("product version active status"),
        help_text=_("bool; optional; default: False"),
        default=False,
    )
    _view_count = models.PositiveIntegerField(
        _("number of views"),
        help_text=_("required, starts with 0"),
        default=0,
    )
    made_in = models.CharField(_("change this to country FK"), max_length=150)
    # created_at = models.DateTimeField(
    #    _("product version creation time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now_add=True,
    # )
    # updated_at = models.DateTimeField(
    #    _("product version last update time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now=True,
    # )

    objects = ProductVersionManager()

    def __str__(self) -> str:
        return self.name

    @property
    def views(self) -> int:
        """Get number of customer views for this product version."""
        return self._view_count

    @property
    def discount_rate(self) -> int:
        """Get product version discount rate."""
        discount = 0
        if self.discount_id is None:
            return discount
        if self.discount.is_active:
            now = timezone.now()
            if self.discount.starts_at > now or self.discount.ends_at <= now:
                self.discount.is_active = False
                self.discount.save(update_fields=("is_active",))
            else:
                discount = self.discount.rate
        return discount
        # if self.discount_id is None:
        #    return 0
        # return (
        #    ProductDiscount.objects.values("rate")
        #    .get(id=self.discount_id)
        #    .get("rate")
        # )

    @property
    @decimalize()
    def discounted_price(self) -> Decimal:
        """Get discounted price."""
        # if self.discount_id is None:
        #    return self.regular_price
        # rate = (
        #    ProductDiscount.objects.values("rate")
        #    .get(id=self.discount_id)
        #    .get("rate")
        # )
        # rate = self.discount_rate
        return float(self.regular_price) * ((100 - self.discount_rate) / 100)

    def increment_view_count(self) -> None:
        """Increment number of customer views by 1."""
        # self._meta.model.objects.filter(id=self.id).update(_view_count=F('_view_count')+1)
        self._view_count += 1
        self.save(update_fields=("_view_count",))

    def set_sku(self) -> None:
        """Set sku and save the model."""
        self.sku = self._generate_sku()
        self.save(update_fields=("sku",))

    def _generate_sku(self) -> str:
        """Generate sku from product type, product version id and current date."""
        return f"{self.product.p_type_id:>03}{self.pk:>02}{dt.datetime.now():%Y%m}"

    def to_dict(self) -> Dict[str, Any]:
        """Return a dict of product version attributes."""
        return {
            # "product_id": self.id,
            "name": self.name,
            "sku": self.sku,
            "regular_price": self.regular_price,
            "discount": self.discount_rate,
            "discounted_price": self.discounted_price,
        }


"""
class Media(models.Model):
    p_version = models.ForeignKey(
        ProductVersion, related_name="media", on_delete=models.CASCADE
    )
    image = models.ImageField(
        _("product version image"),
        upload_to="/images",
        default="/images/default.jpg",
        help_text="required, default: default.jpg",
    )
    is_cover = models.BooleanField(
        _("is a cover image"),
        default=False,
        help_text="reuqired, default: False",
    )
    created_at = models.DateTimeField(
        _("image creation time"),
        auto_now_add=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
    updated_at = models.DateTimeField(
        _("image last update time"),
        auto_now=True,
        help_text=_("format: Y-m-d H:M:S"),
    )
"""


class Stock(TimeStampModel, models.Model):
    p_version = models.OneToOneField(
        ProductVersion,
        on_delete=models.PROTECT,
        related_name="stock",
        help_text=_("Product version this stock belongs to."),
    )
    unit = models.CharField(
        _("product unit"),
        help_text=_("required, max_len: 20"),
        max_length=20,
    )
    amount = models.PositiveIntegerField(
        _("current amount of product"),
        help_text=_("required, default: 0"),
        default=0,
    )
    items_sold = models.PositiveIntegerField(
        _("amount of product sold"),
        help_text=_("required, default: 0"),
        default=0,
    )
    # created_at = models.DateTimeField(
    #    _("Stock item creation time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now_add=True,
    # )
    # updated_at = models.DateTimeField(
    #    _("Stock item last update time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now=True,
    # )

    def __str__(self) -> str:
        return f"Product({self.p_version_id}): {self.amount}"

    def set(self, value: int, commit: bool = True) -> None:
        if value < 0 or value > MAX_AMOUNT_ADDED:
            raise ValidationError(
                f"Value must be between 0 and {MAX_AMOUNT_ADDED}"
            )
        self.amount = value
        if commit:
            self.save(update_fields=("amount",))

    def add(self, value: int, commit: bool = True) -> None:
        if value < 0:
            raise ValidationError("Value must be greater or equal to 0")
        if value > MAX_AMOUNT_ADDED:
            raise TooBigToAdd(value)
        self.amount += value
        if commit:
            self.save(update_fields=("amount",))

    def deduct(self, value: int, commit: bool = True) -> None:
        if value < 0:
            raise ValidationError("Value must be greater or equal to 0")
        if value > self.amount:
            raise NotEnoughProductLeft(self)
        self.amount -= value
        if commit:
            self.save(update_fields=("amount",))

    def available(self, amount: int) -> bool:
        return self.amount >= amount


class CartManager(models.Manager):
    def create(self, **kwargs) -> "Cart":
        customer = kwargs.get("customer")
        if customer.status != Customer.CustomerStatus.ACTIVATED:
            msg = _("Cart creation is available only for active customers")
            logger.error(msg)
            raise ValidationError(msg)
        return super().create(**kwargs)


class Cart(TimeStampModel, models.Model):
    # maybe try: Cart.objects.select_related('customer)?
    class CartStatus(models.TextChoices):
        EMPTY = "empty"
        IN_PROGRESS = "in_progress"

    customer = models.OneToOneField(
        Customer,
        related_name="cart",
        on_delete=models.PROTECT,
        verbose_name=_("Cutomer"),
        help_text="required, customer instance",
    )
    status = models.CharField(
        _("Cart status"),
        help_text=_("required, default: empty"),
        max_length=20,
        choices=CartStatus.choices,
        default=CartStatus.EMPTY,
    )
    # created_at = models.DateTimeField(
    #    _("cart creation time"),
    #    auto_now_add=True,
    #    help_text=_("format: Y-m-d H:M:S"),
    # )
    # updated_at = models.DateTimeField(
    #    _("cart last update time"),
    #    auto_now=True,
    #    help_text=_("format: Y-m-d H:M:S"),
    # )

    def __str__(self) -> str:
        return f"{self.id} for Customer({self.customer_id})"

    @property
    def is_empty(self) -> bool:
        """Return True if there is no items in cart.
        False otherwise.
        """
        return not self.items.exists()

    @property
    def items_ready_for_order(self) -> "QuerySet[CartItem]":
        """Queryset of cart items marked ready for order."""
        return self.items.filter(marked_for_order=True)

    def clear(self) -> None:
        """Clean the cart."""
        self.items.all().delete()
        self.status = self.CartStatus.EMPTY
        self.save(update_fields=("status", "updated_at"))

    def refresh(self) -> None:
        """Update all cart items from product version info."""
        # think about save() method runs at every item refresh
        for item in self.items.all():
            item.refresh_from_product_version()

    @decimalize()
    def get_initial_sum(self) -> Decimal:
        """Get sum of all items in cart before discount applied."""
        return (
            self.items.filter(marked_for_order=True)
            .aggregate(initial=Sum(F("regular_price") * F("quantity")))
            .get("initial")
            or 0
        )

    @decimalize()
    def get_discounted_sum(self) -> Decimal:
        """Get sum of all items in cart after dicsount added."""
        return (
            self.items.filter(marked_for_order=True)
            .aggregate(discounted=Sum(F("discounted_price") * F("quantity")))
            .get("discounted")
            or 0
        )

    @decimalize()
    def get_total_discount(self) -> Decimal:
        """Get sum of total cart discount."""
        return (
            self.items.filter(marked_for_order=True)
            .aggregate(
                discount=Sum(
                    (F("regular_price") - F("discounted_price"))
                    * F("quantity")
                )
            )
            .get("discount")
            or 0
        )

    def to_dict(self, refresh: bool = False) -> Dict[str, Any]:
        """Return a dict of cart attributes."""
        if refresh:
            self.refresh()
        return {
            "customer_id": self.customer_id,
            "initial_sum": self.get_initial_sum(),
            "total_discount": self.get_total_discount(),
            "discounted_sum": self.get_discounted_sum(),
        }


class CartItemManager(models.Manager):
    def create_from_product_version(
        self, customer_id: int, product_version_id: int, **kwargs: dict
    ) -> "CartItem":
        """Create CartItem from ProductVersion.
        Prevent creating cart items from inactive products
        and products that don't have enough stock items.
        Fetch stock data along with the product version
        to prevent additional db queries.
        """
        try:
            cart = Cart.objects.get(customer_id=customer_id)
            p_version = ProductVersion.objects.select_related("stock").get(
                id=product_version_id
            )
        except (Cart.DoesNotExist, ProductVersion.DoesNotExist) as e:
            logger.error(f"Model does not exist: {e}")
            raise
        if not p_version.is_active:
            msg = _("Inactive products can't be added to cart")
            logger.error(msg)
            raise ValidationError(msg)
        if not p_version.stock.available(kwargs.get("quantity", 1)):
            msg = _("Not enough product in stock")
            logger.error(msg)
            raise ValidationError(msg)
            # maybe need to deduct from stock to reserve items for order
            # but then need to keep notice of cleansing the cart periodically
        cart_item = self.create(
            cart=cart, p_version=p_version, **kwargs, **p_version.to_dict()
        )
        cart.save(update_fields=("updated_at",))
        return cart_item

    def create(self, **kwargs: Mapping[str, Any]) -> "CartItem":
        """Create cart item.
        Check if a product version is already in the cart.
        If it's there - increase or set cart item quantity.
        If it's not - create new cart item.
        """
        cart = kwargs.get("cart")
        p_version = kwargs.get("p_version")
        quantity = kwargs.get("quantity", 1)
        override_quantity = kwargs.get("override_quantity", False)
        try:
            cart_item = self.get(cart_id=cart.id, p_version_id=p_version.id)
            cart_item.add_quantity(quantity, override_quantity)
        except self.model.DoesNotExist:
            cart_item = super().create(**kwargs)
        except Exception as e:
            logger.error(f"An unexpected error occured: {e}")
            raise e
        if cart.status == Cart.CartStatus.EMPTY:
            cart.status = Cart.CartStatus.IN_PROGRESS
            cart.save(update_fields=("status",))
        return cart_item


class CartItem(TimeStampModel, models.Model):
    cart = models.ForeignKey(
        Cart,
        on_delete=models.CASCADE,
        related_name="items",
        verbose_name=_("Item in cart"),
    )
    p_version = models.ForeignKey(
        ProductVersion,
        on_delete=models.PROTECT,
        related_name="added_to_cart",
        verbose_name=_("Product version"),
    )
    name = models.CharField(
        _("Product version name"),
        help_text=_("optional, max_len: 150"),
        max_length=150,
        blank=True,
    )
    sku = models.CharField(
        _("Product version stock keeping unit"),
        help_text=_("optional, max_len: 20"),
        max_length=20,
    )
    quantity = models.PositiveIntegerField(
        _("Product quantity"),
        help_text=_("reqiured, positive integer"),
        validators=[MinValueValidator(1)],
        default=1,
    )
    regular_price = models.DecimalField(
        _("Price of cart item without discounts"),
        help_text=_("optional, max_price: 9_999_999.99"),
        **decimal_price_settings,
    )
    discount = models.PositiveSmallIntegerField(
        _("Discount rate (integer)"),
        help_text=_("optional, default: 0"),
        validators=[MaxValueValidator(99)],
        default=0,
    )
    discounted_price = models.DecimalField(
        _("Discounted cart item price"),
        help_text=_("optional, max_price: 9_999_999.99"),
        **decimal_price_settings,
    )
    marked_for_order = models.BooleanField(
        _("Item selected to be ordered"),
        help_text=_("required, default: False"),
        default=True,
    )
    # created_at = models.DateTimeField(
    #    _("cart_item creation time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now_add=True,
    # )
    # updated_at = models.DateTimeField(
    #    _("cart_item last update time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now=True,
    # )

    objects = CartItemManager()

    def __str__(self):
        return self.product_name

    def save(self, *args, **kwargs) -> None:
        """Update cart info each time a cart item updated."""
        super().save(*args, **kwargs)
        # self.cart.save(update_fields=("updated_at",))

    def delete(self, **kwargs) -> Tuple[int, Dict[str, int]]:
        """Set cart status to `EMPTY` when all cart items have been deleted."""
        deleted = super().delete(**kwargs)
        if not self._meta.model.objects.filter(cart_id=self.cart_id).exists():
            Cart.objects.filter(id=self.cart_id).update(
                status=Cart.CartStatus.EMPTY, **updated_at()
            )
        return deleted

    def refresh_from_product_version(self) -> None:
        """Refresh cart item attribute values with product version info."""
        self._meta.model.objects.filter(id=self.id).update(
            **self.p_version.to_dict()
        )

    def add_quantity(self, quantity: int, override: bool = False) -> None:
        if override:
            self.quantity = quantity
        else:
            self.quantity += quantity
        self.save(update_fields=("quantity", "updated_at"))

    @decimalize()
    def get_initial_sum(self) -> Decimal:
        """Get sum of cart item without discount."""
        return self.regular_price * self.quantity

    @decimalize()
    def get_discounted_sum(self) -> Decimal:
        """Get discounted sum of cart item."""
        return self.discounted_price * self.quantity

    @decimalize()
    def get_total_discount(self) -> Decimal:
        """Get amount of discount applied to cart item."""
        return (self.regular_price - self.discounted_price) * self.quantity

    def mark_for_order(self) -> None:
        """Mark cart item as ready for order.
        Only marked items are counted in cart sum
        and can be added to order.
        """
        self.marked_for_order = True
        self.save(update_fields=("marked_for_order", "updated_at"))
        Cart.objects.filter(id=self.cart_id).update(
            status=Cart.CartStatus.IN_PROGRESS,
            **updated_at(),
        )

    def unmark_for_order(self) -> None:
        """Remove mark from cart item.
        This item is not counted in cart sum
        and can not be added to order.
        """
        self.marked_for_order = False
        self.save(update_fields=("marked_for_order", "updated_at"))
        if not self._meta.model.objects.filter(
            cart_id=self.cart_id, marked_for_order=True
        ):
            Cart.objects.filter(id=self.cart_id).update(
                status=Cart.CartStatus.EMPTY, **updated_at()
            )

    def to_dict(self) -> Dict[str, Any]:
        """Return a dict of cart item attributes."""
        return {
            # "cart": self.cart,
            # "product_version": self.p_version,
            "name": self.name,
            "p_version_id": self.p_version_id,
            "sku": self.sku,
            "quantity": self.quantity,
            "regular_price": self.regular_price,
            "discount": self.discount,
            "discounted_price": self.discounted_price,
            "initial_sum": self.get_initial_sum(),
            "discounted_sum": self.get_discounted_sum(),
            "total_discount": self.get_total_discount(),
            # "marked_for_order": self.marked_for_order,
        }


class OrderManager(models.Manager):
    def create_from_cart(self, customer_id: int, **kwargs: dict) -> "Order":
        """Create order from cart.
        Before order creation assert that cart exists
        and has items with `marked_for_order` attribute set to `True`.
        Iterate through _marked_ items to create order items.
        Apply cart attributes to newly created order.
        """
        try:
            cart = Cart.objects.get(
                customer_id=customer_id, status=Cart.CartStatus.IN_PROGRESS
            )
        except Cart.DoesNotExist as e:
            logger.error(
                "Create a Cart and add active items before creating an order"
            )
            raise e
        if cart.is_empty:
            msg = _("No active items in cart")
            logger.error(msg)
            raise CartItem.DoesNotExist(msg)

        order = self.create(**kwargs, **cart.to_dict())
        for item in cart.items_ready_for_order:
            OrderItem.objects.create_from_cart_item(order.id, item)
            # OrderItem.create_from_cart_item(order, item)

        # order.final_sum = order.get_total_sum()
        # order.save(update_fields=("final_sum",))
        return order


class Order(TimeStampModel, models.Model):
    class OrderStatus(models.TextChoices):
        PENDING = "pending"
        PAID = "paid"
        PROCESSING = "processing"
        DELIVERY_READY = "delivery_ready"
        ON_DELIVERY = "on_delivery"
        DELIVERED = "delivered"
        FINISHED = "finished"
        CANCELED_BY_CUSTOMER = "canceled_by_customer"
        CANCELED_BY_SELLER = "canceled_by_seller"

    customer = models.ForeignKey(
        Customer,
        on_delete=models.PROTECT,
        related_name="orders",
    )  # change to models.SET_DEFAULT
    _status = models.CharField(
        _("Order status"),
        help_text=_("required, default: pending"),
        max_length=50,
        choices=OrderStatus.choices,
        default=OrderStatus.PENDING,
    )
    # shipment_method = ...
    # payment_method = ...
    # delivery_info = ...  # FK DELIVERY
    initial_sum = models.DecimalField(
        _("order sum without discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        **decimal_sum_settings,
    )
    total_discount = models.DecimalField(
        _("sum of discounts"),
        help_text=_("optional, max_sum: 9 999 999 999.99"),
        default=0,
        **decimal_sum_settings,
    )
    discounted_sum = models.DecimalField(
        _("order sum with discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        **decimal_sum_settings,
    )
    # created_at = models.DateTimeField(
    #    _("order creation time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now_add=True,
    # )
    # updated_at = models.DateTimeField(
    #    _("order last update time"),
    #    help_text=_("format: Y-m-d H:M:S"),
    #    auto_now=True,
    # )

    objects = OrderManager()

    def __str__(self) -> str:
        return f"Order {self.id} for customer {self.customer_id}"

    @property
    def status(self) -> str:
        """Return current order status."""
        return self._status

    @status.setter
    def status(self, value: str) -> None:
        """Set order status."""
        if stat := getattr(self.OrderStatus, value.upper(), None):
            self._status = stat
        else:
            msg = f"{value} is not a valid choice for OrderStatus"
            logger.error(msg)
            raise ValueError(msg)

    def cancel(self, canceled_by: Literal["customer", "seller"]) -> int:
        """Cancel the order.
        Revert all order items and set specific order status.
        Return: int, number of reverted order items."""
        number_canceled = 0
        for item in self.items.all():
            item.revert()
            number_canceled += 1
        self.status = f"canceled_by_{canceled_by.lower()}"
        self.save(update_fields=("_status",))
        return number_canceled


class OrderItemManager(models.Manager):
    def create_from_cart_item(
        self, order_id: int, cart_item: CartItem, **kwargs: dict
    ) -> "OrderItem":
        """Create an order item from a cart item."""
        data = cart_item.to_dict()
        stock = Stock.objects.filter(p_version_id=data.get("p_version_id"))
        quantity = data.get("quantity")
        try:
            success = stock.update(
                amount=F("amount") - quantity,
                items_sold=F("items_sold") + quantity,
            )
        except IntegrityError as e:
            logger.error(_("invalid quantity"))
            raise e
        except Exception as e:
            logger.error(f"unknown error: {e}")
            raise e
        # if product := data.get("product"):
        #    stock = product.stock
        #    # quantity = data.get("quantity", 1)
        #    # if not stock.available(quantity):
        #    #    raise ValidationError(_("Not enough product in stock"))
        #    # stock.deduct(quantity)
        #    try:
        #        stock.deduct(quantity := data.get("quantity", 1), commit=False)
        #    except NotEnoughProductLeft as e:
        #        print(f"{e(quantity)}")
        #        raise
        #    stock.items_sold += quantity
        #    stock.save(
        #        update_fields=(
        #            "current_amount",
        #            "items_sold",
        #        )
        #    )
        if success:
            # kwargs.update(data)
            cart_item.delete()
            return self.create(order_id=order_id, **kwargs, **data)


class OrderItem(models.Model):
    order = models.ForeignKey(
        Order,
        on_delete=models.CASCADE,
        related_name="items",
        verbose_name=_("Customer Order"),
    )
    p_version = models.ForeignKey(
        ProductVersion,
        on_delete=models.PROTECT,
        related_name="order_items",
        verbose_name=_("Ordered product version"),
    )
    name = models.CharField(
        _("Ordered product version name"),
        help_text=_("required, max_len: 150"),
        max_length=150,
    )
    sku = models.CharField(
        _("stock keeping unit"),
        help_text=_("required, max_len: 20"),
        max_length=20,
    )
    quantity = models.PositiveIntegerField(
        _("Quantity of ordered product"),
        help_text=_("required: default 1"),
        default=1,
    )
    regular_price = models.DecimalField(
        _("Final price of ordered product"),
        help_text=_("required, max_price: 9 999 999.99"),
        **decimal_price_settings,
    )
    discount = models.PositiveSmallIntegerField(
        _("Discount rate (integer)"),
        help_text=_("required, default: 0"),
        validators=[MaxValueValidator(99)],
        default=0,
    )
    discounted_price = models.DecimalField(
        _("Discounted oreder item price"),
        help_text=_("required, max_price: 9_999_999.99"),
        **decimal_price_settings,
    )
    initial_sum = models.DecimalField(
        _("Sum of ordered product without discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        **decimal_sum_settings,
    )
    total_discount = models.DecimalField(
        _("Sum of total discounts applied to ordered product"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        **decimal_sum_settings,
    )
    discounted_sum = models.DecimalField(
        _("Final sum of ordered product with discounts"),
        help_text=_("required, max_sum: 9 999 999 999.99"),
        **decimal_sum_settings,
    )
    is_canceled = models.BooleanField(
        _("Was order item canceled"),
        help_text=_("required, default: False"),
        default=False,
    )

    objects = OrderItemManager()

    def __str__(self) -> str:
        return self.product_name

    def revert(self) -> bool:
        """Restore the quantity of stock units when the order is canceled.
        Set quantity item quantity to 0.
        Return: bool, status of revert operation."""
        stock = Stock.objects.filter(p_version_id=self.p_version_id)
        try:
            canceled = stock.update(
                amount=F("amount") + self.quantity,
                items_sold=F("items_sold") - self.quantity,
            )
            canceled = bool(canceled)
        except IntegrityError as e:
            logger.error("invalid values; unable to perform update")
            raise e
        except Exception as e:
            logger.error(f"unknown error: {e}")
            raise e
        # stock = Stock.objects.filter(product_id=self.product_id).first()
        # stock.add(self.quantity, commit=False)
        # stock.items_sold -= self.quantity
        # stock.save(
        #    update_fields=(
        #        "current_amount",
        #        "items_sold",
        #    )
        # )
        # self.quantity = 0
        self.is_canceled = canceled
        self.save(update_fields=("is_canceled",))
        return canceled


class Comment(models.Model):
    pass
